  Future<List<LatLng>> getRoutePoints(LatLng origin, LatLng destination) async {
    print("ğŸ” [DirectionsService] Called with origin: ${origin.latitude},${origin.longitude} -> destination: ${destination.latitude},${destination.longitude}");
    try {
      final url =
          Uri.parse("https://maps.googleapis.com/maps/api/directions/json?"
              "origin=${origin.latitude},${origin.longitude}&"
              "destination=${destination.latitude},${destination.longitude}&"
              "mode=driving&"
              "key=$_apiKey");

      print("ğŸ” [DirectionsService] Calling API: $url");

      final response = await http.get(url);

      print("ğŸ“¡ [DirectionsService] Response status: ${response.statusCode}");
      print("ğŸ“„ [DirectionsService] Response body: ${response.body}");

      if (response.statusCode == 200) {
        final data = json.decode(response.body);

        print("ğŸ” [DirectionsService] API Status: ${data["status"]}");

        if (data["status"] == "OK" && data["routes"].isNotEmpty) {
          final route = data["routes"][0];
          final overviewPolyline = route["overview_polyline"]["points"];
          print("âœ… [DirectionsService] Polyline found: ${overviewPolyline.length} chars");
          final points = _decodePolyline(overviewPolyline);
          print("âœ… [DirectionsService] Decoded ${points.length} points");
          return points;
        } else {
          print("âŒ [DirectionsService] No valid routes found. Status: ${data["status"]}");
          if (data["error_message"] != null) {
            print("âŒ [DirectionsService] Error message: ${data["error_message"]}");
          }
        }
      } else {
        print("âŒ [DirectionsService] HTTP error: ${response.statusCode}");
      }

      // Fallback to straight line if directions fail
      print("âš ï¸ [DirectionsService] Using fallback straight line");
      return [origin, destination];
    } catch (e) {
      print("âŒ [DirectionsService] Exception: $e");
      // Fallback to straight line
      return [origin, destination];
    }
  }
